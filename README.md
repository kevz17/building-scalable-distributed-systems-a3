# Assignment 3 - Improved Responsiveness

## System Design

![alt text](https://github.com/kevz17/building-scalable-distributed-systems-a3/blob/main/a3_system_design.png?raw=true)

As the diagram above shows, the client first sends purchase requests to the servlet, then the servlet publishes requests to the RabbitMQ for asynchronous processing, directing requests to store and purchase microservices to consume. The store microservice stores purchase records in memory, while the purchase microservice stores these records into MySQL database hosted on RDS. The AWS configuration of each part is shown below:

|  | Client | Upgraded Client | Server | RabbitMQ | Purchase Microservice | Store Microservice | Upgraded Store Microservice | Database |
|-|-|-|-|-|-|-|-|-|
| Instance Type | t2.micro | t2.2xlarge | t2.micro | t2.xlarge | t2.micro | t2.micro | t2.xlarge | db.t2.micro |
| Memory (GiB) | 1 | 32 | 1 | 16 | 1 | 1 | 16 | 1 |
| Availability Zone | us-east-1f | us-east-1f | us-east-1f | us-east-1f | us-east-1f | us-east-1f | us-east-1f | us-east-1f |
| Storage Type | gp2 | gp2 | gp2 | gp2 | gp2 | gp2 | gp2 | gp2 |
Note:
1. The server (client-facing servlet) is single without any load balancer added.
2. Both of the client and the store microservice have two configurations of AWS EC2 instances. The
upgraded client is used for testing 512 threads in case of heap out of memory. The upgraded store microservice is also used for storing purchase records (created by 512 threads) in memory avoiding insufficient heap memory.


## Messaging (RabbitMQ Message Queue) Design

RabbitMQ is used for asynchronous messaging in this assignment. By following the RabbitMQ Publish/Subscribe tutorial, the servlet is implemented as publisher along with a fanout type exchange, directing messages to two separate queues for store and purchase consuming. In case of consumer failure, manual acknowledgement is adopted. All the queues are not persistent.


## Server Architecture Design

 - Client-Facing Servlet:
    In order to increase the efficiency of creating channels, a channel pool is created in init() method of servlet using Apache Commons GenericObjectPool referencing http://commons.apache.org/proper/commons- pool/examples.html. During testing, there were 8 channels opening. The servlet consists of two dedicated servlets: PurchaseServlet serves doPost() that publishes messages to RabbitMQ, while StoreServlet serves doGet() that redirects top items/stores result to store microservice.

 - Purchase Microservice:
    For better write performance to MySQL database, multiple consumers are used, complying one consumer per channel with prefetch count equal to 1. The thread pool size of consumers is 32. In the DeliverCallback function, HikariCP database driver is used to connect the purchase consumer to MySQL database and store purchase records. The database connection part is the same as assignment 2.

 - Store Microservice:
    Different from purchase microservice, the store microservice declares a queue that consumed by 32 consumers. The consumers store the purchase records sent from the client through servlet and message queues into heap memory. The in memory database is implemented by ConcurrentHashMap. Two ConcurrentHashMap are introduced to store: a) storeID as key, map from itemID to number of items as value; b) itemID as key, map from storeID to number of items as value. Besides the init() methodâ€™s implementing as consumers, the doGet() of StoreServlet serves the redirected request from client-facing servlet to process the in memory data store and returns the top stores/items. For each GET request, the corresponding ConcurrentHashMap will be sorted in descending order to retrieve the desired top k records.

 - Implementation and Packages
    Jackson is used to transform JSON string into Purchase object. The DataSource is implemented through HikariCP from Maven repository with underlying MySQL configuration set as per the performance tips posted by Brett Wooldridge. (Link: https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration) Apache Commons pool2 is used to create channel pool in the client-facing servlet. RabbitMQ AMQP client is used to implement message queue.

 - Database Schema Design
    Only one table is used to store each purchase data. To realize this design, a composite key of purchaseID and batchID is set as the primary key, where the purchaseID is generated by the PurchaseDao using UUID version 4 while the batchID is set as the order of PurchaseItems in the list using for loop in PurchaseDao. So for each purchase, there will be 5 records to store, all the five records have the same purchaseID, which is size 36 varchar type, have different batchID from 1 to 5. Thus, each record can be uniquely identified by the composite key. Below is the code snippet of the SQL script:
    ```
    CREATE TABLE Purchase (
        purchaseID VARCHAR(36) NOT NULL,
        batchID INT NOT NULL,
        itemID VARCHAR(10) NOT NULL,
        numberOfItems INT NOT NULL,
        storeID INT NOT NULL,
        custID INT NOT NULL,
        date VARCHAR(8) NOT NULL,
        CONSTRAINT pk_Purchase_purchaseID_batchID PRIMARY KEY (purchaseID, batchID)
    );
    ```


## Comparison between Assignment 3 and 2 (256 threads, single server)

| Assignment | 3 | 2 |
|-|-|-|
| Number of Threads | 256 | 256 |
| Total Wall Time (sec) | 161 | 348 |
| Throughput (req/sec) | 4305 | 1985 |
| Success/Fail Request | 691200 / 0 | 691200 / 11 |
| Mean Latency (ms) | 38 | 87 |
| Median Latency | 27 | 58 |
| 99th Percentage Latency | 293 | 887 |
| Max Latency | 1817 | 7569 |


## Results for Testing with 512 Threads

| Assignment | 3 | 2 |
|-|-|-|
| Number of Threads | 512 | 512 |
| Total Wall Time (sec) | 282 | 878 |
| Throughput (req/sec) | 4896 | 1574 |
| Success/Fail Request | 1382400 / 0 | 1382400 / 59 |
| Mean Latency (ms) | 69 | 219 |
| Median Latency | 70 | 238 |
| 99th Percentage Latency | 1115 | 2236 |
| Max Latency | 7938 | 10271 |

